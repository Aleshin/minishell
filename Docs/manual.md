**Проект minishell**
Фундаментальные вещи, с которыми надо хорошо разобраться:
1. Нотация Бакус-Наура (BNF) и ее расширенные версии. Важные термины: правило, терминальный символ, нетерминальный символ.
2. Абстрактное синтаксическое дерево (AST). Начинается из корневого узла (полная командная строка). Каждый узел может иметь произвольное количество дочерних узлов.
3. Рекурсивный спуск (Recursive descent). Метод, когда парсер идет по правилам BNF, спускаясь по нетерминальным символам, пока не достигнет полностью терминального описания.
4. Погуглить "Теория автоматов"
5. Ссылки:
https://m4nnb3ll.medium.com/minishell-building-a-mini-bash-a-42-project-b55a10598218
https://en.wikipedia.org/wiki/Recursive_descent_parser


Алгоритм:
ты создаешь список правил в формате BNF. Каждое правило описывает нетерминальный символ через более простые нетерминальные символы и/или терминальные.
Терминальные символы это те, которые нельзя поделить на другие символы. Эти символы используют регулярные выражения и работают исключительно со знаками.
Иерархия нетерминальных символов базируется на том, что каждый символ представляется в виде набора других нетерминальных символов (включая исходный символ) и, возможно, терминалов.
Для каждого правила создается функция в Си.
Обычно первым шагом запускается лексер. Он делит исходный ввод на токены, используя только терминальные правила. После него командная строка преобразуется в последовательность терминальных символов, включая символ "unknown", куда попадает все, что не удалось идентифицировать с помощью правил.
После этого запускается парсер, который обрабатывает поток токенов с помощью функций для нетерминалов. Если он встречает unknown-токен, то он анализирует контент, сопоставляя его с терминальными элементами правил. Функции работают как матрешка, рекурсивно вызывая следующие или себя, чтобы спуститься по списку правил до терминальных правил.
В ходе такого рекурсивного спуска (Recursive descent) создается синтаксическое дерево (AST), которое можно использовать для экзекьютора. Это дерево состоит из узлов, каждый из которых может содержать произвольное количество дочерних узлов. Дочерние узлы могут быть реализованы через динамический массив (указываем указатель на массив указателей на дочерние узлы и количество элементов этого массива) или через конструкцию first child, next sibling, когда узел имеет один дочерний узел, а остальные дочерние узлы реализованы как цепочка "братьев" этого дочернего узла

Надо разобраться с термминологией: token, symbol, rule