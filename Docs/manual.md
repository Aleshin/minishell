**Проект minishell**
Фундаментальные вещи, с которыми надо хорошо разобраться:
1. Нотация Бакус-Наура (BNF) и ее расширенные версии. Контекстно-независимая грамматика. Важные термины: правило, терминальный символ, нетерминальный символ, токен.

2. Абстрактное синтаксическое дерево (AST). Начинается из корневого узла (полная командная строка). Каждый узел может иметь произвольное количество дочерних узлов.
3. Рекурсивный спуск (Recursive descent). Метод, когда парсер идет по правилам BNF, спускаясь по нетерминальным символам, пока не достигнет полностью терминального описания.
4. Погуглить "Теория автоматов"
5. Ссылки:
https://m4nnb3ll.medium.com/minishell-building-a-mini-bash-a-42-project-b55a10598218
https://en.wikipedia.org/wiki/Recursive_descent_parser


Алгоритм:
ты создаешь список правил в формате BNF. Каждое правило описывает нетерминальный символ через более простые нетерминальные символы и/или терминальные.
Терминальные символы это те, которые нельзя поделить на другие символы. Эти символы используют регулярные выражения и работают исключительно с алфавитно-цифровыми знаками. По факту терминальному символу соответсвует определенный токен
Иерархия нетерминальных символов базируется на том, что каждый символ представляется в виде набора других нетерминальных символов (включая исходный символ) и, возможно, терминалов.
Для каждого правила создается функция в Си.
Обычно первым шагом запускается лексер. Он делит исходный ввод на токены, используя только терминальные правила. После него командная строка преобразуется в последовательность терминальных символов, включая символ "unknown", куда попадает все, что не удалось идентифицировать определенным типом символа с помощью правил.
После этого запускается парсер, который обрабатывает поток токенов с помощью функций для нетерминалов. Если он встречает unknown-токен, то он анализирует контент, сопоставляя его с терминальными элементами правил. Функции работают как матрешка, рекурсивно вызывая следующие или себя, чтобы спуститься по списку правил до терминальных правил.
В ходе такого рекурсивного спуска (Recursive descent) создается синтаксическое дерево (AST), которое можно использовать для экзекьютора. Это дерево состоит из узлов, каждый из которых может содержать произвольное количество дочерних узлов. Дочерние узлы могут быть реализованы через динамический массив (указываем указатель на массив указателей на дочерние узлы и количество элементов этого массива) или через конструкцию first child, next sibling, когда узел имеет один дочерний узел, а остальные дочерние узлы реализованы как цепочка "братьев" этого дочернего узла
Важно, что само дерево (узлы или листья, связанные между собой) создается "снизу вверх". Т.е. функции для правил верхнего уровня, которые вызывают функции, обрабатывающие правила более низкого уровня, "не знают", чем закончится этот вызов и не создают объектов дерева, пока не получат результат. Таким образом, само дерево, в отличии от рекурсивного спуска парсера, создается наоборот, с самого нижнего уровня терминальных символов (Bottom-up tree construction)

Надо разобраться с термминологией: token, symbol, rule
Сильно помогает разобраться с грамматикой и протестировать bnf инструмент ANTLR https://www.antlr.org